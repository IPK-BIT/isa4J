/**
 * Copyright (c) 2019 Leibniz Institute of Plant Genetics and Crop Plant Research (IPK), Gatersleben, Germany.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the GNU GPLv3 license (https://www.gnu.org/licenses/gpl-3.0.en.html)
 *
 * Contributors:
 *      Leibniz Institute of Plant Genetics and Crop Plant Research (IPK), Gatersleben, Germany
 */
package de.ipk_gatersleben.bit.bi.isa.components;

import de.ipk_gatersleben.bit.bi.isa.constants.StudyAssayAttribute;
import de.ipk_gatersleben.bit.bi.isa.constants.Symbol;
import de.ipk_gatersleben.bit.bi.isa4j.components.Comment;
import de.ipk_gatersleben.bit.bi.isa4j.components.Factor;
import de.ipk_gatersleben.bit.bi.isa4j.components.Protocol;

import java.util.*;

public class RowOfAssay extends Row {

	/**
	 * an identifier to the Assay Node.
	 */
	private String assayName;

	/**
	 * Name (or URI) of the raw data file generated by an assay. No format
	 * restrictions.
	 */
	private String rawDataFile;

	/**
	 * Name (or URI) of the derived data file generated from raw data by data
	 * processing.
	 */
	private String derivedDataFile;

	private String imageFile;

	/**
	 * get raw data file
	 *
	 * @return get raw data file
	 */
	public String getRawDataFile() {
		return rawDataFile;
	}

	/**
	 * set get raw data file
	 *
	 * @param rawDataFile get raw data file
	 */
	public void setRawDataFile(String rawDataFile) {
		this.rawDataFile = rawDataFile;
	}

	/**
	 * get assayname
	 *
	 * @return assayname
	 */
	public String getAssayName() {
		return assayName;
	}

	/**
	 * set assayname
	 *
	 * @param assayName name of assay
	 */
	public void setAssayName(String assayName) {
		this.assayName = assayName;
	}

	public String getDerivedDataFile() {
		return derivedDataFile;
	}

	public void setDerivedDataFile(String derivedDataFile) {
		this.derivedDataFile = derivedDataFile;
	}

	public String getImageFile() {
		return imageFile;
	}

	public void setImageFile(String imageFile) {
		this.imageFile = imageFile;
	}

	/**
	 * The function will get the template of all components in rows. The parameters
	 * of this function are the lists of components. They should be new list and
	 * after this function they will be the templates.
	 *
	 * @param orderOfCharacteristic template of characteristics
	 * @param orderOfComment        template of comment
	 * @param orderOfProtocol       template of protocol
	 * @param orderOfParameter      template of parameter
	 * @param orderOfFactor         template of factor
	 * @param rowsOfAssay           list of rowOfAssay
	 */
	public static List<Boolean> getTemplateOfRows(List<Characteristic> orderOfCharacteristic,
			List<Comment> orderOfComment, List<Protocol> orderOfProtocol, Map<String, List<Parameter>> orderOfParameter,
			Map<String, List<Characteristic>> orderOfCharacteristicInProtocol, List<Factor> orderOfFactor,
			List<Characteristic> orderOfSampleCharacteristics, List<RowOfAssay> rowsOfAssay,
			Set<String> ontologySourceREF) {
		Map<String, Characteristic> motherOfCharacteristics = new HashMap<>();
		Map<String, Comment> motherOfComment = new HashMap<>();
		Map<String, Protocol> motherOfProtocols = new HashMap<>();
		Map<String, Map<String, Parameter>> motherOfParameters = new HashMap<>();
		Map<String, Map<String, Characteristic>> motherOfCharacteristicsInProtocol = new HashMap<>();
		Map<String, Factor> motherOfFactors = new HashMap<>();
		Map<String, Characteristic> motherOfSampleCharacteristics = new HashMap<>();

		Set<Integer> hasPositionOfCharacteristic = new HashSet<>();
		Set<Integer> orderPositionOfCharacteristic = new HashSet<>();
		Set<Integer> hasPositionOfComment = new HashSet<>();
		Set<Integer> orderPositionOfComment = new HashSet<>();
		Set<Integer> hasPositionOfProtocol = new HashSet<>();
		Set<Integer> orderPositionOfProtocol = new HashSet<>();
		HashMap<String, HashSet<Integer>> hasPositionOfParameter = new HashMap<>();
		HashMap<String, HashSet<Integer>> orderPositionOfParameter = new HashMap<>();
		HashMap<String, HashSet<Integer>> hasPositionOfCharacteristicsInProtocol = new HashMap<>();
		HashMap<String, HashSet<Integer>> orderPositionOfCharacteristicsInProtocol = new HashMap<>();
		Set<Integer> hasPositionOfFactor = new HashSet<>();
		Set<Integer> orderPositionOfFactor = new HashSet<>();
		Set<Integer> hasPositionOfSampleCharacteristics = new HashSet<>();
		Set<Integer> orderPositionOfSampleCharacteristics = new HashSet<>();

		boolean imageFileFlag = false;
		boolean rawDataFileFlag = false;
		boolean derivedDataFileFlag = false;
		for (RowOfAssay rowOfAssay : rowsOfAssay) {
			if (!rowOfAssay.addComponentsToTemplate(motherOfCharacteristics, hasPositionOfCharacteristic,
					orderPositionOfCharacteristic, motherOfComment, hasPositionOfComment, orderPositionOfComment,
					motherOfProtocols, hasPositionOfProtocol, orderPositionOfProtocol, motherOfParameters,
					hasPositionOfParameter, orderPositionOfParameter, motherOfCharacteristicsInProtocol,
					hasPositionOfCharacteristicsInProtocol, orderPositionOfCharacteristicsInProtocol, motherOfFactors,
					hasPositionOfFactor, orderPositionOfFactor, motherOfSampleCharacteristics,
					hasPositionOfSampleCharacteristics, orderPositionOfSampleCharacteristics, ontologySourceREF)) {
				return null;
			}
			if (rowOfAssay.getImageFile() != null) {
				imageFileFlag = true;
			}
			if (rowOfAssay.getRawDataFile() != null) {
				rawDataFileFlag = true;
			}
			if (rowOfAssay.getDerivedDataFile() != null) {
				derivedDataFileFlag = true;
			}
		}
		sortTemplateWithPosition(motherOfCharacteristics, orderOfCharacteristic, motherOfComment, orderOfComment,
				motherOfProtocols, orderOfProtocol, motherOfParameters, orderOfParameter,
				motherOfCharacteristicsInProtocol, orderOfCharacteristicInProtocol, motherOfFactors, orderOfFactor,
				motherOfSampleCharacteristics, orderOfSampleCharacteristics);

		List<Boolean> list = new ArrayList<>();
		list.add(imageFileFlag);
		list.add(rawDataFileFlag);
		list.add(derivedDataFileFlag);
		return list;
	}

	/**
	 * Get attribute of assay, it uses the template to get attributes. In this
	 * function it will differentiate, which one should have ontoloy
	 *
	 * @param templateOfCharacteristic template of characteristic
	 * @param templateOfProtocol       template of protocol
	 * @param templateOfParameter      template of parameter
	 * @param templateOfFactor         template of factor
	 * @param templateOfComment        template of comment
	 * @return the attribute of assay
	 */
	public static String getAttributeOfAssay(List<Characteristic> templateOfCharacteristic,
			List<Protocol> templateOfProtocol, Map<String, List<Parameter>> templateOfParameter,
			Map<String, List<Characteristic>> templateOfCharacteristicInProtocol, List<Factor> templateOfFactor,
			List<Comment> templateOfComment, boolean imageFileFlag, boolean rawDataFileFlag,
			boolean derivedDataFileFlag) {
		StringBuilder content = new StringBuilder();

		content.append(StudyAssayAttribute.SAMPLE_NAME);

		content.append(Characteristic.getAttributeWithTemplate(templateOfCharacteristic));
		content.append(Protocol.getAttributeWithTemplate(templateOfProtocol, templateOfParameter,
				templateOfCharacteristicInProtocol));

		content.append(StudyAssayAttribute.ASSAY_NAME);

		if (imageFileFlag) {
			content.append(StudyAssayAttribute.IMAGE_FILE);
		}
		if (rawDataFileFlag) {
			content.append(StudyAssayAttribute.RAW_DATA_FILE);
		}
		if (derivedDataFileFlag) {
			content.append(StudyAssayAttribute.DERIVED_DATA_FILE);
		}

		content.append(Factor.getAttributeWithTemplate(templateOfFactor));

		content.append(Comment.getAttributeWithTemplate(templateOfComment));
		content.deleteCharAt(content.lastIndexOf(Symbol.TAB.toString()));
		content.append(Symbol.ENTER);
		return content.toString();

	}

	/**
	 * Get this row's data
	 *
	 * @param templateOfCharacteristic template of characteristic
	 * @param templateOfProtocol       template of protocol
	 * @param templateOfParameter      template of parameter
	 * @param templateOfFactor         template of factor
	 * @param templateOfComment        template of comment
	 * @param imageFileFlag            if has image file
	 * @param rawDataFileFlag          if has raw data file
	 * @param derivedDataFileFlag      if has derived Data file
	 * @return string
	 */
	public String getDataOfRow(List<Characteristic> templateOfCharacteristic, List<Protocol> templateOfProtocol,
			Map<String, List<Parameter>> templateOfParameter,
			Map<String, List<Characteristic>> templateOfCharacteristicInProtocol, List<Factor> templateOfFactor,
			List<Comment> templateOfComment, boolean imageFileFlag, boolean rawDataFileFlag,
			boolean derivedDataFileFlag) {

		StringBuilder content = new StringBuilder();

		content.append((getSampleName() == null ? Symbol.EMPTY.toString() : getSampleName())).append(Symbol.TAB);

		content.append(Characteristic.getDataWithTemplate(templateOfCharacteristic, getCharacteristics()));

		content.append(Protocol.getDataWithTemplate(templateOfProtocol, templateOfParameter,
				templateOfCharacteristicInProtocol, getProtocols()));

		content.append(assayName == null ? Symbol.EMPTY.toString() : assayName).append(Symbol.TAB);

		if (imageFileFlag) {
			content.append((getImageFile() == null ? Symbol.EMPTY.toString() : getImageFile())).append(Symbol.TAB);
		}
		if (rawDataFileFlag) {
			content.append((getRawDataFile() == null ? Symbol.EMPTY.toString() : getRawDataFile())).append(Symbol.TAB);
		}
		if (derivedDataFileFlag) {
			content.append((getDerivedDataFile() == null ? Symbol.EMPTY.toString() : getDerivedDataFile()))
					.append(Symbol.TAB);
		}

		content.append(Factor.getDataWithTemplate(templateOfFactor, getFactors()));

		content.append(Comment.getDataWithTemplate(templateOfComment, getComments()));

		content.deleteCharAt(content.lastIndexOf(Symbol.TAB.toString()));

		return content.toString();
	}
}
