## Welcome
isa4J is a comprehensive and scalable Java Library for the programmatic generation of experimental metadata descriptions using the ISATab container format.
We're assuming you're familiar with the ISA-Tab framework in the remainder of the manual; if you're not, please [read up about it first](https://isa-specs.readthedocs.io/en/latest/).

## 1. License and Citation
The software provided as-is and made available under the terms of the GNU GPLv3 license (https://www.gnu.org/licenses/gpl-3.0.en.html), granting you the freedom to run, use, study, share, and modify the software in any way you want as long as any derivative work is distributed under the same or equivalent terms ([details](https://en.wikipedia.org/wiki/GNU_General_Public_License#Terms_and_conditions)).
If you're referring to isa4J in a scientific publication, we'd be grateful if you could cite our paper:

> Citation forthcoming

## 2. Installation
The isa4J library will be available in the central Maven Repository and can be used by common build management tools.

## 3. Usage

### 3.1 Creating the Investigation File
Usually it makes sense to build up the Investigation file first and define all the Parameters, Protocols, Ontologies etc. that you want to use in your corresponding Study and Assay files. With only a few exceptions, isa4J classes and attributes are named in keeping with the [ISA model](https://github.com/ISA-tools/isa-api/tree/master/isatools/resources/schemas/isa_model_version_1_0_schemas/core), so if you're familiar with those or the [python API](https://github.com/ISA-tools/isa-api), isa4J will feel quite intuitive. Alternatively, you can read this documentation to understand the general design concept. 
All ISA related classes are located in the `de.ipk_gatersleben.bit.bi.isa4j.components` package.

If you're new to ISATab, it may be also helpful to look at the TestInvestigation.writeToStream Unit test and read the Investigation File generated by it in parallel, so you can see what ends up where(TODO LINK). If something is still unclear, feel free to get in touch with us.

#### 3.1.1 Investigations
To start a new Investigation project, simply create an Investigation object:

```java
Investigation investigation = new Investigation("InvestigationID");

investigation.setTitle("Investigation Title");
investigation.setDescription("Investigation Description");
investigation.setSubmissionDate(LocalDate.of(2019, 12, 22));
investigation.setPublicReleaseDate(LocalDate.of(2020, 1, 16));
```

#### 3.1.2 Ontologies
To refer to an ontology later on in the Investigation, Study or Assay files, define them on a central place and add them to your Investigation.

```java
Ontology creditOntology = new Ontology(
	"CRediT",						// Name of the ontology
	new URL("http://purl.org/credit/ontology"),		// URL to the ontology
	"1.2",							// Version of the ontology
	"CASRAI Contributor Roles Taxonomy (CRediT)"		// Short description of the ontotlogy
);

investigation.addOntology(creditOntology);
```

#### 3.1.3 OntologyAnnotations
To improve the re-usability and quality of your metadata it is helpful to use as much as possible `OntologyAnnotation`s for described attributes instead of a simple String.
They allow you to connect a `term` to an ontology (`term source`) and identify it with a `term accession number`.
The latter two are optional though, and if you don't set them an OntologyAnnotation will be formatted like a simple String in most cases.

```java
OntologyAnnotation paperPublished = new OntologyAnnotation(
	"Published",			// Term
	"<TermAccessionNumber>",	// Term Accession Number
	creditOntology			// Ontology object
);
```

#### 3.1.4 Publications
To link any publication to the Investigation, you can do so similarly to ontologies:

```java
Publication statsStories = new Publication("Five Things ... about Statistics that is", "Philip M. Dixon");

statsStories.setDOI("https://doi.org/10.4148/2475-7772.1013");
statsStories.setStatus(paperPublished); // this is the OntologyAnnotation we defined before

investigation.addPublication(statsStories);
```

#### 3.1.5 Contacts
Contacts can be added using the `Person` type:

```java
Person schlomo = new Person(
	"Schlomo", // First Name
	"Hootkins", // Last Name
	"schlomoHootkins@miofsiwa.foo", // Email
	"Ministry of Silly Walks", // Affiliation
	"4 Hanover House, 14 Hanover Square, London W1S 1HP" // Address
);

Person agatha  = new Person("Agatha", "Stroganoff", null, "Stroganoff Essential Eels", null);
agatha.setFax("+49 3553N714L 33l2"); // Agatha doesn't have an email or a postal address, but a fax number

// Add them as investigation contacts
investigation.addContact(schlomo);
investigation.addContact(agatha);
```

#### 3.1.6 Comments
The different components of the data model can be enriched with comments. Their `CommentCollection` is accessible through the `.comments()` method and provides the methods `add(Comment)`, `getAll`, and `findByName(String)`.

```java
schlomo.comments().add(new Comment("method name", "MyMethod"));
schlomo.comments().add(new Comment("analysis software", "Analyzer Pro"));
schlomo.comments().getAll() // Returns a List<Comment>
schlomo.comments().findByName("method name") // Returns an Optional<Comment>
investigation.comments().add(new Comment("Usability", "high"));
```

#### 3.1.7 Studies
At some point you will want to create one or more Study objects and attach them to your Investigation.
Each Study needs an identifier and a filename, if no filename is given it will be automatically constructed from the identifier.

```java
Study study1 = new Study("Study1ID", "s_study1.txt");
Study study2 = new Study("Study2ID"); // now the filename will be automatically set to "s_Study2ID.txt"
investigation.addStudy(study1);
investigation.addStudy(study2);
```

Study objects are very similar to Investigation objects in that they can also have a title and description and that you can also populate them with Contacts, Publications.
In addition to Investigations, Studies can also contain Factors and Protocols which can then be referenced from the Study File of that Study (right now we're still constructing the Investigation File, even though we are talking about Studies).

```java
Factor soilCoverage = new Factor("soil coverage", new OntologyAnnotation("Factor Type"));
study1.addFactor(soilCoverage);
Protocol plantTalking = new Protocol("Plant Talking");
plantTalking.addComponent(new ProtocolComponent("Component Name", new OntologyAnnotation("Component Type")));
ProtocolParameter toneOfVoice = new ProtocolParameter("Tone of Voice");
plantTalking.addParameter(toneOfVoice);
```

#### 3.1.8 Assays
Finally each Study can contain one or more Assays.
They only need a filename/path and no identifier.

```java
Assay assay1 = new Assay("a_assay.txt");
study1.addAssay(assay1);
```

#### 3.1.9 Writing the File
When you have added everything, you can simply write the Investigation File to a location you specify:

```java
investigation.writeToFile("./i_investigation.txt");
```

Please note that unlike the `isatab.dump` method from the [python API](https://github.com/ISA-tools/isa-api), this only writes the Investigation File and no Study or Assay Files.
They have to be written separately (see sections below).

Instead of writing to a file, you can also write to an open outputstream (e.g. if you're using isa4J in a REST server application)

```java
OutputStream os = new ByteArrayOutputStream(); // of course you would already have a stream
investigation.writeToStream(os);
```

### 3.2 Writing Study and Assay files
isa4J is designed to work with study and assay files that are too large to fit in memory, so instead of populating a study object with all sources and samples and then writing everything in one go, you build and flush out the file iteratively.
First you tell isa4J to open the file for writing:

```java
study1.openFile(); // study1 is defined above and should be attached to an Investigation
```

This will use the filename that you passed when you created the study or that you set with `.setFilename`, so no argument is needed here (this is done to ensure the filename mentioned in the Investigation File matches the one you actually write to).

You then create Source and Sample Objects, connect them via a Process and flush them out into the file before creating the next set of objects (Of course instead of looping through meaningless numbers, you would loop through your database entries, CSV entries, or whatever things you have that you want to describe with ISA-Tab.):

```java
for(int i = 0; i < 5; i++) {
	Source source = new Source("Source Name");
	Sample sample = new Sample("Sample Name");
	Process talkingProcess = new Process(plantTalking); // plantTalking is a Protocol defined above
	talkingProcess.setInput(source);
	talkingProcess.setOutput(sample);

	// WRITE TO FILE HERE (see below)
}
```

The method to write a line to the Study File is `writeLine(initiator)`, `initiator` being the first object in the line that is then connected via a chain of processes and samples/materials etc. to the last (that's why you did `talkingProcess.setInput` and `talkingProcess.setOutput`).
In our case that initator would be `source`.
But if you call `study1.writeLine(source)` at the marked location above, you will be met with an error:

```
Exception in thread "main" java.lang.IllegalStateException: Headers were not written yet
```

The reason is that, as mentioned before, isa4J doesn't know anything about the structure of the rows before or after the current one.
So if, for example, a Source in a later line has a Characteristic attached to it, that needs to be accounted for by having a corresponding entry in the file header and keeping an empty column for all the Sources that do not have this Characteristic.
That is why you have to explicitly tell isa4J what headers you need by passing an examplary initiator (e.g. Source) connected to a Process/Sample/Material/Datafile chain *that contains every field any of your future rows will need*:

```java
study1.writeHeadersFromExample(source);
```

So you need to figure out what your Study File should look like before you start to write it.
In our case it's easy though, because all lines are of a homogenous structure and you can simply include it in the loop:

```java
for(int i = 0; i < 5; i++) {
	Source source = new Source("Source Name");
	Sample sample = new Sample("Sample Name");
	Process talkingProcess = new Process(plantTalking); // plantTalking is a Protocol defined above
	talkingProcess.setInput(source);
	talkingProcess.setOutput(sample);

	if(!study1.hasWrittenHeaders())
		study1.writeHeadersFromExample(source);
	study1.writeLine(source);
}
```

Alternatively you could create one dummy or mock Object set above the loop and write the headers from that, but in many situations this will be the easiest way and worth the small performance cost of checking for headers at each iteration.

After you have written everything you want to write, you can close the file with

```java
study1.closeFile();
```

#### 3.2.1 Attributes for Sources, Samples, Processes etc.
In the real world, Sources and Samples often have more than just a name.
You can attach, depending on the type of object, ParameterValues (for Processes), FactorValues (for Samples), and Characteristics (Sources, Samples, and Materials).
Many objects can also be annotated with Comments.
The way you do this is very similar to how you populated the Investigation File above:

```java
Source source = new Source("Source Name");
source.addCharacteristic(new Characteristic("Characteristic 1", new OntologyAnnotation("Characteristic1Value","Char1Acc",creditOntology))); // creditOntology defined above

Sample sample = new Sample("Sample Name");
sample.addFactorValue(new FactorValue(
	soilCoverage, // Factor devined above
	34.12, // Value (can also be a String or an OntologyAnnotation)
	new OntologyAnnotation("%") // Unit
));

Process process = new Process(plantTalking);
process.addParameterValue(
	new ProtocolParameter(toneOfVoice, "soft") // similar to FactorValue: can have double/string/OntologyAnnotation values and an optional unit
); 

// Comments work the same way as before
source.comments().add(new Comment("Comment Name", "Comment Value"));
```

Of course it makes sense to define Objects that you are going to use multiple times outside of your loop, so a slightly more realistic example could look like this:

```java
Characteristic species = new Characteristic("Organism", new OntologyAnnotation("Arabidopsis thaliana","http://purl.obolibrary.org/obo/NCBITaxon_3702",ncbiTaxonomy)); // ontology not defined here
ParameterValue softSpeaking = new ParameterValue(toneOfVoice, "Very softly");
study1.openFile();
for(int i = 0; i < 5; i++) {
	Source source = new Source("Source Name");
	source.addCharacteristic(species);
	Sample sample = new Sample("Sample Name");
	sample.addFactorValue(new FactorValue(soilCoverage, i*10, new OntologyAnnotation("%")));
	Process talkingProcess = new Process(plantTalking); // plantTalking is a Protocol defined above
	talkingProcess.addParameterValue(softSpeaking);
	talkingProcess.setInput(source);
	talkingProcess.setOutput(sample);

	if(!study1.hasWrittenHeaders())
		study1.writeHeadersFromExample(source);
	study1.writeLine(source);
}
study1.closeFile();
```

#### 3.2.2 Writing to Streams
Like the Investigation File, you can also write Study Files to a stream instead of a file.

```java
study1.directToStream(os); // os = some OutputStream, instead of study1.openFile()
// Write your lines here
study1.releaseStream(); // instead of study1.closeFile()
```

The stream will not be closed by these methods so you can keep using it if you want to send anything after the study file content.

#### 3.3.3 What about Assays?
Assays work in the exact same way that Studies do, they also have `openFile, writeHeadersFromExample, writeLine, closeFile` as well as `directToStream` and `releaseStream` methods.
In addition to Sources and Samples, you may want to make use of the `Material` and `DataFile` classes when writing Assay Files (although you **can** also use them in the Study File).

```java
Material material = new Material("Extract Name", "Extract No. 232");
extractionProcess.setInput(sample);
extractionProcess.setOutput(material);

DataFile sequenceFile = new DataFile("Raw Data File", "seq-232.fasta");
sequencingProcess.setInput(material);
sequencingProcess.setOutput(sequenceFile);
```

As you can see here, lines can contain more than one Processes, so instead of the simple `Source->Process->Sample` chain we constructed above, it can also be more complex (like here: `Sample->Process->Material->Process->Datafile`).
There is no limit to the amount of things you can connect, just make sure you always set the correct in- and outputs for the connecting processes.

#### 3.3.4 Writing Concurrently
If you have multiple study or assay files and want to create them even faster, you can also parallelize the creation process for each of them into a separate thread or process.
Just make sure you're not writing to the same file from multiple threads/processes at the same time, that will create chaos.


### 3.4 Things to Look Out For

- All Strings passed to isa4J will be sanitized to make sure they don't break the format. Practically that means all TABs and ENTERs will be converted to spaces. Watch out for that if you're passing data from somewhere into isa4J and then parsing the files somewhere else back into a database: The result will not be the same as the initial input.

## ISA JSON

isa4J does not provide export functions to the ISA JSON format.
If you need ISA JSON files, you can create ISATab files with isa4J and then [convert them with the python API](https://isatools.readthedocs.io/en/latest/conversions.html).
The conversion is very straightforward and easy to do even if you have no experience working in python.
